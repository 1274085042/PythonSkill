*进程：* 对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。  
*线程：* 有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。  

*小结*  
线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。

如果要同时执行多个任务怎么办？

有两种解决方案：

一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。

还有一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。

当然还有第三种方法，就是启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。
多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。  

## 进程  
### `multiprocessing` 模块中的 `Process` 用于创建一个子进程。  
```
p=Process(target= , args=())  #创建子进程时，需要出入一个执行函数和该函数的参数
p.start()                     #启动该进程
p.join()                      #等待子进程结束后再继续往下执行，通常用于进程间的同步
```  
### Pool 用进程池的方式批量创建子进程
```
from multiprocessing import Pool

p=Pool(4)
for i in range(5):
    p.apply_async(func,args=())
p.close()
p.join()
```  
代码解读：  
对`Pool`对象调用`join()`方法会等待所有子进程执行完毕，调用`join()`之前必须先调用`close()`，调用`close()`之后就不能继续添加新的Process了（关闭进程池）。  
`Pool`的默认大小是CPU的核数。  
### 进程间的通信
Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。  
[`进程间的通信`](./multi_process.py#L72)  
### 小结
在Unix/Linux下，可以使用fork()调用实现多进程。

要实现跨平台的多进程，可以使用multiprocessing模块。

进程间通信是通过Queue、Pipes等实现的。